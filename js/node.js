
/*
    All information about a node but nothing about graphs and no actual physics calculations

    TODO: 
        - Fix the bug where inspector says current edge angles are NaN when making a triangle
        - Combine edge data into a dictionary so the properties of this class aren't so cluttered
        - Make a dedicated function to calculate angular force magnitudes with a little more complexity
        - Prevent explosions by capping forces applied
        - Add some kind of damping or prevent infinite gliders or mimic conservation of energy in some other way
            - Backwards acceleration?
        - Implement a more standarized unit and scale to help calibrate calculations to realistic levels?
        - Make angular force calculations relative to local node rotation rather than global reference angle.
            - Just make an updated version of the ref angle function that calculates relative to a parameter rather than
              the new (0, 1) vector!
        - Remove the gridOrigin arg from render()
*/
class Node{
    constructor(position, mass, index){
        this.indexInGraph = index;  // This is a sin, I understand. I have done this for my son.

        this.mass = mass;
        this.position = position;
        this.rotation = 0.0;
        this.velocity = createVector(0, 0);
        this.netForce = createVector(0, 0);
        
        this.edges = [];
        this.edgeCurrentAngles = [];
        this.edgeTargetAngles = []; // To find and maintain the relative angles of edges to each other
        
        this.incidentNodeForces = [];   // The force to apply to each incident node
        this.netTorque = 0.0;
        this.angularVelocity = 0.0;
        
        this.angularRigidity = 100;
        this.angularDampingFactor = 0.9;    // Values 0-1 where 1 is total damping

        this.radius = 25;
        this.bounciness = 0.4;
        this.dragStrength = 0.8;    // Higher values -> more drag
        
        this.constrainedX = false;
        this.constrainedY = false;

        this.bShouldTick = true;
    }


    // Calculate a physics step
    tick(deltaTime){
        if(this.bShouldTick){
            // Apply acceleration and position
            let acceleration = p5.Vector.div(this.netForce, this.mass);
            this.velocity.add(p5.Vector.mult(acceleration, deltaTime));
            this.position.add(p5.Vector.mult(this.velocity, deltaTime));
    
            // Clear net force
            this.netForce = createVector(); 
    
            // Generate a drag force based on velocity
            let drag = this.velocity.copy();
            drag.mult(-1);
            drag.mult(this.dragStrength);
            this.applyForce(drag);

            // Apply bottom boundary
            if(this.position.y > 0){
                this.position.y = 0;
                this.velocity.y *= -this.bounciness;
                this.netForce.y = 0;
            }
    
            let fGravity = createVector(0, 9.8 * this.mass);
    
            // Apply gravity
            this.applyForce(fGravity);
        }

        this.tickAngular(deltaTime);
    }
    

    cycleConstraintType(){
        if(!this.constrainedX && !this.constrainedY){
            this.constrainedX = true;
        }
        else if(this.constrainedX && !this.constrainedY){
            this.constrainedX = false;
            this.constrainedY = true;
        }
        else if(!this.constrainedX && this.constrainedY){
            this.constrainedX = true;
        }
        else{
            this.constrainedX = false;
            this.constrainedY = false;
        }
    }

    
    // Calculate torque and apply forces to neighboring nodes
    tickAngular(deltaTime){
        if(this.getEdgeCount() > 0){
            // let normalTorques = []; // Torques generated by the 'rigidity' of the node
            // let appliedTorques = [];
            let normalTorque = 0;
            let appliedTorque = 0;

            // Loop through all neighbors and find the applied and normal torques
            this.edges.forEach((edge, i) => {
                let otherNode = edge.getIncidentNode(this);
                this.updateAngleToNeighbor(i, otherNode);   // Update relative neighbor angle
                let currentAngle = this.edgeCurrentAngles[i];
                let targetAngle = this.edgeTargetAngles[i];
                let angularDisplacement = Geometry.getAngleDifference(targetAngle, currentAngle);

                // Find the torque generated by the rigidity of the node against this neighbor
                let nTorqueMag = pow(angularDisplacement * this.angularRigidity, 2);
                let nTorqueDir = angularDisplacement > 0 ? 1 : -1;
                let nTorque = nTorqueMag * nTorqueDir;
                // normalTorques.push(nTorque);
                normalTorque += nTorque;
                
                // Find the torque generated by the net force on this neighbors
                let edgeLength = this.edges[i].getCurrentLength();
                /*
                    Note: Here, the force applied by the other node to this node must be derived from its relative velocity. 
                    Consider that when both nodes are moving in the same direction there will be no torque applied.
                */
                let aTorque = Physics.calculateTorque2D(this.position, otherNode.netForce, otherNode.position);
                // appliedTorques.push(aTorque);
                appliedTorque += aTorque.z;
            });

            // Update the net torque by adding the generated and applied torques
            // console.log("applied torque: " + appliedTorque);
            // console.log("normal torque: " + normalTorque);


            // this.edges.forEach((edge, i) => {
            //     let otherNode = edge.getIncidentNode(this);

            //     // Find & apply the forces on neighbors
            //     let neighborForceMag = Physics.calculateForceOnArm(nTorqueMag, edgeLength);
            //     let neighborForce = Geometry.getPerpendicularVector(this.position, otherNode.position);
            //     neighborForce.setMag(nTorqueDir * neighborForceMag);
            //     this.incidentNodeForces[i] = neighborForce;
            //     otherNode.applyForce(neighborForce);
            // });
        }

        // Update rotation on this node (probably calculated wrong)
        // let angularAcceleration = this.netTorque / this.mass;
        // this.angularVelocity += angularAcceleration * deltaTime;
        // this.rotation += this.angularVelocity * deltaTime;
        
        // Clear torque
        // this.netTorque = 0;

        // To apply angular drag to nodes, find the component of their velocity relative to neighbors along the arc prescribed by their edge and use it to generate a force in the opposite direction.
    }



    // Return the force to apply to an incident node
    calcRotationalForceOnNeighbor(neighborNode, currentAngle, targetAngle, index){
        let referenceAngle = this.getReferenceAngleToNode(neighborNode);
        let actualAngle = Geometry.updateAngle(currentAngle, referenceAngle);
        let angularDisplacement = Geometry.getAngleDifference(targetAngle, actualAngle);
        let forceToApply = Geometry.getPerpendicularVector(this.position, neighborNode.position);
        let edgeLength = this.edges[index].getCurrentLength();
        let torqueForceMag = pow(angularDisplacement * this.angularRigidity, 2);
        let torqueForceDirection = angularDisplacement > 0 ? 1 : -1;

        // console.log(currentAngle)
        forceToApply.setMag(torqueForceDirection * Physics.calculateForceOnArm(torqueForceMag, edgeLength));

        this.edgeCurrentAngles[index] = actualAngle;
        this.incidentNodeForces[index] = forceToApply;

        return forceToApply;
    }


    // Updates the angle between the rotation of this node and a neighbor
    updateAngleToNeighbor(edgeIndex, neighborNode){
        let currentAngle = this.edgeCurrentAngles[edgeIndex];
        let newAngle = Geometry.updateAngle(currentAngle, this.getRelativeAngleToNode(neighborNode));
        this.edgeCurrentAngles[edgeIndex] = newAngle;
        return newAngle;
    }


    // 
    render(gridOrigin, color){
        const nodeSize = 15;

        // Unconstrained
        if(!this.constrainedX && !this.constrainedY){
            noStroke();
            fill(color);
            ellipse(gridOrigin.x + this.position.x, gridOrigin.y + this.position.y, nodeSize, nodeSize);
        }
        // Constrained on x
        if(this.constrainedX){
            strokeWeight(5);
            stroke(color);
            line(
                gridOrigin.x + this.position.x, 
                gridOrigin.y + this.position.y - (nodeSize / 2),
                gridOrigin.x + this.position.x, 
                gridOrigin.y + this.position.y + (nodeSize / 2),
            )
        }
        // Constrained on y
        if(this.constrainedY){
            strokeWeight(5);
            stroke(color);
            line(
                gridOrigin.x + this.position.x - (nodeSize / 2), 
                gridOrigin.y + this.position.y,
                gridOrigin.x + this.position.x + (nodeSize / 2), 
                gridOrigin.y + this.position.y,
            )
        }
        // Geometry.drawVector(this.velocity, p5.Vector.add(gridOrigin, this.position), BLUE);
        
        // Render collision bubble
        stroke(200);
        strokeWeight(0.3);
        noFill();
        ellipse(gridOrigin.x + this.position.x, gridOrigin.y + this.position.y, this.radius*2, this.radius*2);
        
        // Render node index
        fill(0);
        let textOffset = 15;
        text(String(this.indexInGraph), gridOrigin.x + this.position.x + textOffset, gridOrigin.y + this.position.y + textOffset);

        // Render line to show rotation
        // stroke(color);
        // strokeWeight(2);
        // let lineBegin = createVector(gridOrigin.x + this.position.x, gridOrigin.y + this.position.y);
        // let lineEnd = p5.Vector.fromAngle(this.rotation, 20);
        // line(lineBegin.x, lineBegin.y, lineBegin.x + lineEnd.x, lineBegin.y + lineEnd.y);

        // Render incident node forces
        // this.incidentNodeForces.forEach((force, i) => {
        //     let incidentNodePosition = this.edges[i].getIncidentNode(this).position;
        //     Geometry.drawVector(force, p5.Vector.add(incidentNodePosition, gridOrigin), GREEN);
        // })
    }

    
    // Add an existing edge
    addEdge(edge){
        this.edges.push(edge);
    }


    
    // Add a neighbor by creating a new edge
    addIncidentNode(node){

    }

    
    // Maybe fill out later
    calculateTorque(edge){
        
    }
    
    
    // 
    applyForce(force){
        if(this.bShouldTick){
            this.netForce.add(force);
        }
    }
    
    
    // 
    applyTorque(force){
        if(this.bShouldTick){
            this.netTorque += force;
        }
    }
    

    // Return the angle between the horizontal, this node, and the given edge
    getAngleToEdge(edgeIndex){
        return this.getReferenceAngle(this.position, edgeIndex.getIncidentNode(this).position);
    }


    // Return angle between horizontal and the given node
    getReferenceAngleToNode(node){
        return Geometry.getReferenceAngle(this.position, node.position);
    }


    // Return the angle between this node's rotation and the given node
    getRelativeAngleToNode(node){
        let rotVector = p5.Vector.fromAngle(this.rotation, 1);  // A point that the rotation aims at
        rotVector.add(this.position);
        return Geometry.getAngleBetween(this.position, rotVector, node.position);
    }


    getEdgeCount(){
        return this.edges.length;
    }
}